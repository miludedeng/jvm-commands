### athrow

----

**操作**

抛出一个异常实例(exception 或者 error)

**格式**

|  athrow |
| --------:   |



**结构**
```
athrow = 191(0xbf)
```

**操作数栈**
```
..., objectref →
objectref
```

**描述**

objectref 必须为一个 reference 类型的数据，它指向一个 Throwable 或其子类的对象实例。在指令执行时，objectref 首先从操作数栈中出栈，然后通过§2.10中描述的算法搜索当前方法中与objectref的类 型相匹配的第一个异常处理器。

如果找到了适合 objectref 的异常处理器，这个异常处理器将包 一个用于 处理此异常的代码位置。PC 寄存器的值就会被重设为异常处理器指定的那个 位置上，整个当前栈帧的操作数栈都会被清空，objectref 重新压入到操作 数栈中，然后程序继续执行。

如果在当前栈帧中没有找到适合的异常处理器，那么栈帧就要从操作数栈中出 栈，如果当前栈帧对应的方法是一个同步方法，那在方法调用时持有或重入的 管程就应当释放(对于重入来说是计数减 1)，就像执行了 monitorexit 一 样。最后，这个栈帧的调用者被恢复。如果此栈帧仍然没有找到合适的异常处 理器，那它也会继续退出，objectref 也会不断重新抛出，假设已经没有任 何的栈帧可以退出，那当前线程将被结束掉。

**运行时异常**

如果 objectref 为 null，athrow 指令将会抛出 NullPointerException 来代替 objectref 所代表的异常。

另外，如果虚拟机实现没有严格执行在同步中规定的结构化锁定规则， 导致当前方法是一个同步方法，但当前线程在调用方法时没有成功持有或重入相应的管程，那 athrow 指令将会抛出 IllegalMonitorStateException 异常。这是可能出现的，譬如一个同步方法只包 了对方法同步对象的 monitorexit 指令，但是 包 配对的 monitorenter 指令。

另外，如果虚拟机实现严格执行了同步中规定的结构化锁定规则，但当前方法调用时，其中的第一条规则被违反的话，athrow 指令也会抛出 IllegalMonitorStateException 异常。

**注意**

athrow 指令的操作数栈图( 表中“操作数栈”行的图)可能会产生一些误 解:如果当前方法中某个异常处理器被匹配到，athrow 指令将抛弃掉操作数 栈上所有的值，然后重新将被抛出的异常对象入栈，但是如果在当前方法中没 有找到适合的异常处理器，即异常被抛到方法调用链其他地方时，被清空的和objectref 入栈的操作数栈是真正处理异常的那个方法的操作数栈，而从最 初抛出异常的那个方法一直到最终处理异常的那个方法(不 )之间的栈帧全 部都会被丢弃掉。
