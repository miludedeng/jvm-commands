### invokestatic

----

**操作**

调用静态方法

**格式**

|invokestatic|
|--------:|
|indexbyte1|
|indexbyte2|

**结构**
```
invokestatic = 184(0xb8)
```

**操作数栈**
```
„，[arg1，[arg2 ...]] →
„
```

**描述**

无符号数indexbyte1和indexbyte2用于构建一个当前类的运行时常量池的索引值，构建方式为(indexbyte1<<8)|indexbyte2，
该索引所指向的运行时常量池项应当是一个方法的符号引用，它包了方法的名称和描述符，以及包该方法的接口的符号引用。此方法应是已被解析过的，而且不能是实例的初始化方法和类或接口的初始化方法。这个方法必须被声明为static，因此它也不能是abstract方法。

在方法被成功解析之后，如果方法所在的类没有被初始化过，那指令执行时将会触发其初始化过程。

在操作数栈中必须包连续n个参数值，这些参数的数值、数据类型和顺序都必须遵循实例方法的描述符中的描述。

如果要调用的是同步方法，那与这个类的Class对象相关的管程(monitor)将会进入或者重入，就如当前线程中同执行了monitorenter指令一般。

如果要调用的不是地方法，n个args参数将从操作数栈中出栈。方法调用的时候，一个新的栈帧将在Java虚拟机栈中被创建出来，连续的n个参数将存放到新栈帧的局部变量表中，arg1存为局部变量1(如果arg1是long或double类型，那将占用局部变量1和2两个位置)，依此类推。参数中的浮点类型数据在存入局部变量之前会先进行数值集合转换。新栈帧创建后就成为当前栈帧，Java虚拟机的PC寄存器被设置成指向调用方法的首条指令，程序就从这里开始继续执行。

如果要调用的是地方法，要是这些平台相关的代码尚绑定到虚拟机中的话，绑定动作先要完成。指令执行时，n个args参数将从操作数栈中出栈并作为参数传递给实现此方法的代码。参数中的浮点类型数据在传递给调用方法之前会先进行数值集合转换。参数传递和代码执行都会以具体虚拟机实现相关的方式进行。当这些平台相关的代码返回时:
* 如果这个地方法是同步方法，那与它所属类的Class对象相关的管程状态将会被更新，也可能退出了，就如当前线程中同执行了monitorexit指令一般。
* 如果这个地方法有返回值，那平台相关的代码返回的数据必须通过某种实现相关的方式转换成地方法所定义的Java类型，并压入到操作数栈中。

**链接时异常**

在类、接口或者数组的符号解析阶段，任何在解析中的异常都可能被抛出。

另外，如果调用方法是实例方法，那invokestatic指令将抛出IncompatibleClassChangeError异常。

**运行时异常**

如果invokestatic指令执行时触发了类的初始化过程，那invokestatic指令有可能所有在初始化中存在的异常。

另外，如果执行的方法是native方法的话，当实现代码实现代码无法绑定到虚拟机中，那invokestatic指令将抛出UnsatisfiedLinkError异常。

**注意**

方法调用使用到的n个参数的总个数并非与局部变量表的个数是一一对应的，因为参数中的long和double类型参数需要使用2个连续的局部变量来存储，因此在参数传递的时候，可能需要比参数个数更多的局部变量。
